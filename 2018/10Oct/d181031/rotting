 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18



rotate 5

0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18

hop1 = 0
hop2 = 5
tmp1 = arr[hop2] (5)
arr[hop2] = arr[hop1]
0  1  2  3  4  0  6  7  8  9 10 11 12 13 14 15 16 17 18
hop2 += 5;
tmp2 = arr[hop2]; (10)
arr[hop2] = tmp1; (5)
0  1  2  3  4  0  6  7  8  9  5 11 12 13 14 15 16 17 18
tmp1 = tmp2;
hop2 += 5;
tmp2 = arr[hop2]; (15)
arr[hop2] = tmp1; (10)
0  1  2  3  4  0  6  7  8  9  5 11 12 13 14 10 16 17 18
tmp1 = tmp2;


how long to loop?
Intuitively, I'd say arraylength
in other words, 
loop arraylength times:
	hop = (hop + rot)%arraylength
however...
if arraylength = 1,000,000 and rot = 20, you'll finish your MILLION steps, and only be 1/20th done
alternatively, arraylength / rot
but that leaves out the delightful example of rot=23, which will get it done in one take.


how many different loops?






0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25

20 1  2  3  4  0  6  7  8  9  5 11 12 13 14 10 16 17 18 19 15 21 22 23 24

in this case, we're done once through the LINE (in other words 25/5)
and we do 5 loops, starting at 0, 1, 2, 3 & 4 (5 loops, 25%5)
It's a little dumb to do 25, because both div and mod are the same, so it's ambiguous
Also, HEY WAITAMINUTE! we were rotating 15!!!
so NOW what?

0  1  2  3  4 15  6  7  8  9 20 11 12 13 14  0 16 17 18 19  5 21 22 23 24 10
Now THAT's 5 times through, and we'll need to do it 5 times.  The only difference
is, because the rot * the gcd is greater than the array length, we need to mod/wrap
it with each loop {afterthought: not rot * gcd, arraylength / gcd}

step 1: find GCD
step 2: hop replace loop 0 arraylength/GCD times
step 3: if GCD > 1, hoploop GCD times, starting at n.  so if GCD is 3, loop at 0, 1 & 2

var gcd = function(a,b) { return (!b)?a:gcd(b,a%b); };


